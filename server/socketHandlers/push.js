var db = require('../db');
var r = require('rethinkdb');
var parseToRows = require('../utils/parseToRows');
var parseToObj = require('../utils/parseToObj');
var config = require('../config');


exports.setup = function(socket, io) {
	/**
	*@apiGroup push
	*@apiName push
	*@api {socket} push Add a javascript object as a new child at the specified url
	*
	*@apiParam {Object} pushRequest An object that contains path and data as properties
	*@apiParam {String} pushRequest.path A string that specifies which path to add the javascript object as a child of
	*@apiParam {Object} pushRequest.data A javascript object to add as a child at the specified path
	*
	*@apiSuccess (childAddSuccess) {Object} childAddSuccessObject The javascript object that was added as a child to the specified url
	*@apiSuccess (pushSuccess) {Object} pushSuccessObject Javascript object that contains the generated key
	*@apiSuccess (pushSuccess) {String} pushSuccessObject.key The key generated by the database for the newly pushed item
	*@apiSuccess (pushSuccess) {Boolean} pushSuccessObject.created Boolean value indicating where the push was successful
	*/
	// create a copy of original request if you are RETURNING the original data, parseToRows WILL mutate the original data.
	socket.on('push', function(pushRequest) {
		//makes a copy of the original object - there is probably a better way to do this
		var original = JSON.parse(JSON.stringify(pushRequest));
		db.connect(function(conn) {
			//insert an empty document into the database so that we can get the key back from the database to use later
			r.db(config.dbName).table(config.tableName).insert({}).run(conn, function(err, result) {
				//returns an array even if only once key was made
				var generatedKey = result.generated_keys[0];
				//convert object to be pushed into rows to store in the db
				var rows = parseToRows(pushRequest.data, pushRequest.path, generatedKey);
				var rootRow = rows.slice(rows.length-1)[0];
				var childRows = rows.slice(0,rows.length-1);
				//update the empty document we inserted to contain the properties of the root node/row
				r.db(config.dbName).table(config.tableName).get(generatedKey).update(rootRow).run(conn);
				//insert all the child rows - do these two queries simultaneously because they're not dependent on each other
				r.table(config.tableName).insert(childRows).run(conn, function(err, results) {
					//return the key of the root node back to the user so the can use it for subsequent requests
					socket.emit(original.path + '-pushSuccess', {created: true, key: generatedKey});
					//emit to clients listening for child add events at this url
					io.to(original.path + "-" + "childadd").emit(original.path + "-" + "childaddSuccess", original.data);
				});
			});
		});
	});
}