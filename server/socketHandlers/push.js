var db = require('../db');
var r = require('rethinkdb');
var parseToRows = require('../utils/parseToRows');
var parseToObj = require('../utils/parseToObj');
var config = require('../config');
var insertQuery = require('../rethinkQuery/insertQuery');
var updateByKeyQuery = require('../rethinkQuery/updateByKeyQuery');
var bubbleUp = require('../utils/bubbleUp');


exports.setup = function(socket, io) {
	/**
	*@apiGroup push
	*@apiName push
	*@api {socket} push Add a javascript object as a new child at the specified url
	*
	*@apiParam {Object} pushRequest An object that contains path and data as properties
	*@apiParam {String} pushRequest.path A string that specifies which path to add the javascript object as a child of
	*@apiParam {Object} pushRequest.data A javascript object to add as a child at the specified path
	*
	*@apiSuccess (childAddSuccess) {Object} childAddSuccessObject The javascript object that was added as a child to the specified url
	*@apiSuccess (pushSuccess) {Object} pushSuccessObject Javascript object that contains the generated key
	*@apiSuccess (pushSuccess) {String} pushSuccessObject.key The key generated by the database for the newly pushed item
	*@apiSuccess (pushSuccess) {Boolean} pushSuccessObject.created Boolean value indicating where the push was successful
	*/
	// create a copy of original request if you are RETURNING the original data, parseToRows WILL mutate the original data.
	socket.on('push', function(pushRequest) {
		//makes a copy of the original object - there is probably a better way to do this
		var originalRequest = JSON.parse(JSON.stringify(pushRequest));
		//insert an empty document into the database so that we can get the key back from the database to use later
		insertQuery({}, function(result) {
			var generatedKey = result.generated_keys[0];
			//convert object to be pushed into rows to store in the db
			var rows = parseToRows(pushRequest.data, pushRequest.path, generatedKey);
			var rootRow = rows.slice(rows.length-1)[0];
			var childRows = rows.slice(0,rows.length-1);
			//update the empty document we inserted to contain the properties of the root node/row
			updateByKeyQuery(generatedKey, rootRow, function(result) {
				//insert all the child rows - do these two queries simultaneously because they're not dependent on each other
				insertQuery(childRows, function(result) {
					//return the key of the root node back to the user so the can use it for subsequent requests
					socket.emit(originalRequest.path + '-pushSuccess', {created: true, key: generatedKey});
					//emit to clients listening for child add events at this url
					// io.to(original.path + "-" + "child_added").emit(original.path + "-" + "child_added", original.data);
					// console.log(originalRequest);
          bubbleUp('child_added', originalRequest.path, io, originalRequest.data);
				});
			});
		});
	});
};